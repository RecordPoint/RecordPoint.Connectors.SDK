// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// This is the Records365 vNext Connector API Home
    /// </summary>
    public partial class ApiClient : ServiceClient<ApiClient>, IApiClient
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        public JsonSerializerSettings SerializationSettings { get; private set; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        public JsonSerializerSettings DeserializationSettings { get; private set; }

        /// <summary>
        /// Subscription credentials which uniquely identify client subscription.
        /// </summary>
        public ServiceClientCredentials Credentials { get; private set; }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected ApiClient(params DelegatingHandler[] handlers) : base(handlers)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected ApiClient(HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : base(rootHandler, handlers)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        protected ApiClient(System.Uri baseUri, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        protected ApiClient(System.Uri baseUri, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ApiClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (credentials == null)
            {
                throw new System.ArgumentNullException("credentials");
            }
            Credentials = credentials;
            if (Credentials != null)
            {
                Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ApiClient(ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (credentials == null)
            {
                throw new System.ArgumentNullException("credentials");
            }
            Credentials = credentials;
            if (Credentials != null)
            {
                Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ApiClient(System.Uri baseUri, ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new System.ArgumentNullException("credentials");
            }
            BaseUri = baseUri;
            Credentials = credentials;
            if (Credentials != null)
            {
                Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the ApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ApiClient(System.Uri baseUri, ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new System.ArgumentNullException("credentials");
            }
            BaseUri = baseUri;
            Credentials = credentials;
            if (Credentials != null)
            {
                Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// An optional partial-method to perform custom initialization.
        ///</summary>
        partial void CustomInitialize();
        /// <summary>
        /// Initializes client properties.
        /// </summary>
        private void Initialize()
        {
            BaseUri = new System.Uri("http://localhost/connector");
            SerializationSettings = new JsonSerializerSettings
            {
                Formatting = Newtonsoft.Json.Formatting.Indented,
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new  List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            DeserializationSettings = new JsonSerializerSettings
            {
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            CustomInitialize();
        }
        /// <summary>
        /// Gets a collection of aggregations that match a single metadata field value.
        /// </summary>
        /// <param name='fieldName'>
        /// The name of the metadata field.
        /// </param>
        /// <param name='fieldValue'>
        /// The required value of the metadata field.
        /// </param>
        /// <param name='pagesize'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IList<AggregationSubmissionOutputModel>>> ApiAggregationsByFieldNameByFieldValueGetWithHttpMessagesAsync(string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (fieldName == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "fieldName");
            }
            if (fieldValue == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "fieldValue");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("fieldName", fieldName);
                tracingParameters.Add("fieldValue", fieldValue);
                tracingParameters.Add("pagesize", pagesize);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiAggregationsByFieldNameByFieldValueGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Aggregations/{fieldName}/{fieldValue}").ToString();
            _url = _url.Replace("{fieldName}", System.Uri.EscapeDataString(fieldName));
            _url = _url.Replace("{fieldValue}", System.Uri.EscapeDataString(fieldValue));
            List<string> _queryParameters = new List<string>();
            if (pagesize != null)
            {
                _queryParameters.Add(string.Format("pagesize={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(pagesize, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IList<AggregationSubmissionOutputModel>>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IList<AggregationSubmissionOutputModel>>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Submits aggregations to Records365 vNext.
        /// All aggregations are to be submitted to this endpoint.
        /// </summary>
        /// <param name='item'>
        /// The aggregation to be managed.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ErrorResponseModel>> ApiAggregationsPostWithHttpMessagesAsync(AggregationSubmissionInputModel item = default(AggregationSubmissionInputModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (item != null)
            {
                item.Validate();
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("item", item);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiAggregationsPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Aggregations").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(item != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(item, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 202 && (int)_statusCode != 400)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ErrorResponseModel>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 400)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Submits a content source event to the Records365 vNext audit log.
        /// </summary>
        /// <param name='auditEvent'>
        /// Audit event.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ErrorResponseModel>> ApiAuditEventsPutWithHttpMessagesAsync(ConnectorAuditEventModel auditEvent = default(ConnectorAuditEventModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (auditEvent != null)
            {
                auditEvent.Validate();
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("auditEvent", auditEvent);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiAuditEventsPut", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/AuditEvents").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PUT");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(auditEvent != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(auditEvent, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ErrorResponseModel>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 400)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Submits a binary to be archived and protected by Records365 vNext.
        /// </summary>
        /// <param name='connectorId'>
        /// The ID of the connector submitting the binary
        /// </param>
        /// <param name='itemExternalId'>
        /// The ExternalID of the item that the binary belongs to
        /// </param>
        /// <param name='binaryExternalId'>
        /// The ExternalID of the binary
        /// </param>
        /// <param name='fileName'>
        /// An optional file name to associate with the binary
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ErrorResponseModel>> ApiBinariesPostWithHttpMessagesAsync(string connectorId = default(string), string itemExternalId = default(string), string binaryExternalId = default(string), string fileName = default(string), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("connectorId", connectorId);
                tracingParameters.Add("itemExternalId", itemExternalId);
                tracingParameters.Add("binaryExternalId", binaryExternalId);
                tracingParameters.Add("fileName", fileName);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiBinariesPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Binaries").ToString();
            List<string> _queryParameters = new List<string>();
            if (connectorId != null)
            {
                _queryParameters.Add(string.Format("ConnectorId={0}", System.Uri.EscapeDataString(connectorId)));
            }
            if (itemExternalId != null)
            {
                _queryParameters.Add(string.Format("ItemExternalId={0}", System.Uri.EscapeDataString(itemExternalId)));
            }
            if (binaryExternalId != null)
            {
                _queryParameters.Add(string.Format("BinaryExternalId={0}", System.Uri.EscapeDataString(binaryExternalId)));
            }
            if (fileName != null)
            {
                _queryParameters.Add(string.Format("FileName={0}", System.Uri.EscapeDataString(fileName)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 412)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ErrorResponseModel>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 400)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Gets a connector configure model by its connector ID.
        /// </summary>
        /// <param name='id'>
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ConnectorConfigModel>> ApiConnectorConfigurationsByIdGetWithHttpMessagesAsync(System.Guid id, string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("id", id);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiConnectorConfigurationsByIdGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/ConnectorConfigurations/{id}").ToString();
            _url = _url.Replace("{id}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(id, SerializationSettings).Trim('"')));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 404)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ConnectorConfigModel>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ConnectorConfigModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get all connectors for the given clientId across all tenants
        /// </summary>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IList<ConnectorConfigModel>>> ApiConnectorConfigurationsGetWithHttpMessagesAsync(string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiConnectorConfigurationsGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/ConnectorConfigurations").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 404)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IList<ConnectorConfigModel>>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IList<ConnectorConfigModel>>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Gets a collection of items that match a single metadata field value.
        /// </summary>
        /// <param name='fieldName'>
        /// The name of the metadata field.
        /// </param>
        /// <param name='fieldValue'>
        /// The required value of the metadata field.
        /// </param>
        /// <param name='pagesize'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IList<ItemSubmissionOutputModel>>> ApiItemsByFieldNameByFieldValueGetWithHttpMessagesAsync(string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (fieldName == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "fieldName");
            }
            if (fieldValue == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "fieldValue");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("fieldName", fieldName);
                tracingParameters.Add("fieldValue", fieldValue);
                tracingParameters.Add("pagesize", pagesize);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiItemsByFieldNameByFieldValueGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Items/{fieldName}/{fieldValue}").ToString();
            _url = _url.Replace("{fieldName}", System.Uri.EscapeDataString(fieldName));
            _url = _url.Replace("{fieldValue}", System.Uri.EscapeDataString(fieldValue));
            List<string> _queryParameters = new List<string>();
            if (pagesize != null)
            {
                _queryParameters.Add(string.Format("pagesize={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(pagesize, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IList<ItemSubmissionOutputModel>>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IList<ItemSubmissionOutputModel>>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Submits an item to be managed by Records365 vNext.
        /// All records are to be submitted to this endpoint.
        /// </summary>
        /// <param name='item'>
        /// The item to be managed.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> ApiItemsPostWithHttpMessagesAsync(ItemSubmissionInputModel item = default(ItemSubmissionInputModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (item != null)
            {
                item.Validate();
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("item", item);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiItemsPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Items").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(item != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(item, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 202 && (int)_statusCode != 400)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ItemAcceptanceModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 202)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ItemAcceptanceModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 400)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Gets a collection of notifications that are awaiting processing and
        /// acknowledgement by the connector.
        /// </summary>
        /// <param name='connectorId'>
        /// The query information
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IList<ConnectorNotificationModel>>> ApiNotificationsByConnectorIdGetWithHttpMessagesAsync(string connectorId, string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (connectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "connectorId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("connectorId", connectorId);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiNotificationsByConnectorIdGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Notifications/{connectorId}").ToString();
            _url = _url.Replace("{connectorId}", System.Uri.EscapeDataString(connectorId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IList<ConnectorNotificationModel>>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IList<ConnectorNotificationModel>>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Acknowledges a notification as having been processed by the connector.
        /// </summary>
        /// <param name='acknowledge'>
        /// The acknowledgement information.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ErrorResponseModel>> ApiNotificationsPostWithHttpMessagesAsync(ConnectorNotificationAcknowledgeModel acknowledge = default(ConnectorNotificationAcknowledgeModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (acknowledge != null)
            {
                acknowledge.Validate();
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("acknowledge", acknowledge);
                tracingParameters.Add("acceptLanguage", acceptLanguage);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "ApiNotificationsPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/Notifications").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (acceptLanguage != null)
            {
                if (_httpRequest.Headers.Contains("Accept-Language"))
                {
                    _httpRequest.Headers.Remove("Accept-Language");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Accept-Language", acceptLanguage);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(acknowledge != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(acknowledge, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 404)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ErrorResponseModel>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 404)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponseModel>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// This is the Records365 vNext Connector API Home
    /// </summary>
    public partial interface IApiClient : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Subscription credentials which uniquely identify client
        /// subscription.
        /// </summary>
        ServiceClientCredentials Credentials { get; }


        /// <summary>
        /// Gets a collection of aggregations that match a single metadata
        /// field value.
        /// </summary>
        /// <param name='fieldName'>
        /// The name of the metadata field.
        /// </param>
        /// <param name='fieldValue'>
        /// The required value of the metadata field.
        /// </param>
        /// <param name='pagesize'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<AggregationSubmissionOutputModel>>> ApiAggregationsByFieldNameByFieldValueGetWithHttpMessagesAsync(string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Submits aggregations to Records365 vNext.
        /// All aggregations are to be submitted to this endpoint.
        /// </summary>
        /// <param name='item'>
        /// The aggregation to be managed.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ErrorResponseModel>> ApiAggregationsPostWithHttpMessagesAsync(AggregationSubmissionInputModel item = default(AggregationSubmissionInputModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Submits a content source event to the Records365 vNext audit log.
        /// </summary>
        /// <param name='auditEvent'>
        /// Audit event.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ErrorResponseModel>> ApiAuditEventsPutWithHttpMessagesAsync(ConnectorAuditEventModel auditEvent = default(ConnectorAuditEventModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Submits a binary to be archived and protected by Records365 vNext.
        /// </summary>
        /// <param name='connectorId'>
        /// The ID of the connector submitting the binary
        /// </param>
        /// <param name='itemExternalId'>
        /// The ExternalID of the item that the binary belongs to
        /// </param>
        /// <param name='binaryExternalId'>
        /// The ExternalID of the binary
        /// </param>
        /// <param name='fileName'>
        /// An optional file name to associate with the binary
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ErrorResponseModel>> ApiBinariesPostWithHttpMessagesAsync(string connectorId = default(string), string itemExternalId = default(string), string binaryExternalId = default(string), string fileName = default(string), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a connector configure model by its connector ID.
        /// </summary>
        /// <param name='id'>
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ConnectorConfigModel>> ApiConnectorConfigurationsByIdGetWithHttpMessagesAsync(System.Guid id, string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all connectors for the given clientId across all tenants
        /// </summary>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<ConnectorConfigModel>>> ApiConnectorConfigurationsGetWithHttpMessagesAsync(string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a collection of items that match a single metadata field
        /// value.
        /// </summary>
        /// <param name='fieldName'>
        /// The name of the metadata field.
        /// </param>
        /// <param name='fieldValue'>
        /// The required value of the metadata field.
        /// </param>
        /// <param name='pagesize'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<ItemSubmissionOutputModel>>> ApiItemsByFieldNameByFieldValueGetWithHttpMessagesAsync(string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Submits an item to be managed by Records365 vNext.
        /// All records are to be submitted to this endpoint.
        /// </summary>
        /// <param name='item'>
        /// The item to be managed.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ApiItemsPostWithHttpMessagesAsync(ItemSubmissionInputModel item = default(ItemSubmissionInputModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets a collection of notifications that are awaiting processing and
        /// acknowledgement by the connector.
        /// </summary>
        /// <param name='connectorId'>
        /// The query information
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<ConnectorNotificationModel>>> ApiNotificationsByConnectorIdGetWithHttpMessagesAsync(string connectorId, string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Acknowledges a notification as having been processed by the
        /// connector.
        /// </summary>
        /// <param name='acknowledge'>
        /// The acknowledgement information.
        /// </param>
        /// <param name='acceptLanguage'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ErrorResponseModel>> ApiNotificationsPostWithHttpMessagesAsync(ConnectorNotificationAcknowledgeModel acknowledge = default(ConnectorNotificationAcknowledgeModel), string acceptLanguage = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Extension methods for ApiClient.
    /// </summary>
    public static partial class ApiClientExtensions
    {
            /// <summary>
            /// Gets a collection of aggregations that match a single metadata field value.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fieldName'>
            /// The name of the metadata field.
            /// </param>
            /// <param name='fieldValue'>
            /// The required value of the metadata field.
            /// </param>
            /// <param name='pagesize'>
            /// The maximum number of items to return.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static IList<AggregationSubmissionOutputModel> ApiAggregationsByFieldNameByFieldValueGet(this IApiClient operations, string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string))
            {
                return operations.ApiAggregationsByFieldNameByFieldValueGetAsync(fieldName, fieldValue, pagesize, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets a collection of aggregations that match a single metadata field value.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fieldName'>
            /// The name of the metadata field.
            /// </param>
            /// <param name='fieldValue'>
            /// The required value of the metadata field.
            /// </param>
            /// <param name='pagesize'>
            /// The maximum number of items to return.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<AggregationSubmissionOutputModel>> ApiAggregationsByFieldNameByFieldValueGetAsync(this IApiClient operations, string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiAggregationsByFieldNameByFieldValueGetWithHttpMessagesAsync(fieldName, fieldValue, pagesize, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Submits aggregations to Records365 vNext.
            /// All aggregations are to be submitted to this endpoint.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='item'>
            /// The aggregation to be managed.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static ErrorResponseModel ApiAggregationsPost(this IApiClient operations, AggregationSubmissionInputModel item = default(AggregationSubmissionInputModel), string acceptLanguage = default(string))
            {
                return operations.ApiAggregationsPostAsync(item, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Submits aggregations to Records365 vNext.
            /// All aggregations are to be submitted to this endpoint.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='item'>
            /// The aggregation to be managed.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ErrorResponseModel> ApiAggregationsPostAsync(this IApiClient operations, AggregationSubmissionInputModel item = default(AggregationSubmissionInputModel), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiAggregationsPostWithHttpMessagesAsync(item, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Submits a content source event to the Records365 vNext audit log.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='auditEvent'>
            /// Audit event.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static ErrorResponseModel ApiAuditEventsPut(this IApiClient operations, ConnectorAuditEventModel auditEvent = default(ConnectorAuditEventModel), string acceptLanguage = default(string))
            {
                return operations.ApiAuditEventsPutAsync(auditEvent, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Submits a content source event to the Records365 vNext audit log.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='auditEvent'>
            /// Audit event.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ErrorResponseModel> ApiAuditEventsPutAsync(this IApiClient operations, ConnectorAuditEventModel auditEvent = default(ConnectorAuditEventModel), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiAuditEventsPutWithHttpMessagesAsync(auditEvent, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Submits a binary to be archived and protected by Records365 vNext.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='connectorId'>
            /// The ID of the connector submitting the binary
            /// </param>
            /// <param name='itemExternalId'>
            /// The ExternalID of the item that the binary belongs to
            /// </param>
            /// <param name='binaryExternalId'>
            /// The ExternalID of the binary
            /// </param>
            /// <param name='fileName'>
            /// An optional file name to associate with the binary
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static ErrorResponseModel ApiBinariesPost(this IApiClient operations, string connectorId = default(string), string itemExternalId = default(string), string binaryExternalId = default(string), string fileName = default(string), string acceptLanguage = default(string))
            {
                return operations.ApiBinariesPostAsync(connectorId, itemExternalId, binaryExternalId, fileName, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Submits a binary to be archived and protected by Records365 vNext.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='connectorId'>
            /// The ID of the connector submitting the binary
            /// </param>
            /// <param name='itemExternalId'>
            /// The ExternalID of the item that the binary belongs to
            /// </param>
            /// <param name='binaryExternalId'>
            /// The ExternalID of the binary
            /// </param>
            /// <param name='fileName'>
            /// An optional file name to associate with the binary
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ErrorResponseModel> ApiBinariesPostAsync(this IApiClient operations, string connectorId = default(string), string itemExternalId = default(string), string binaryExternalId = default(string), string fileName = default(string), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiBinariesPostWithHttpMessagesAsync(connectorId, itemExternalId, binaryExternalId, fileName, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Gets a connector configure model by its connector ID.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='id'>
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static ConnectorConfigModel ApiConnectorConfigurationsByIdGet(this IApiClient operations, System.Guid id, string acceptLanguage = default(string))
            {
                return operations.ApiConnectorConfigurationsByIdGetAsync(id, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets a connector configure model by its connector ID.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='id'>
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ConnectorConfigModel> ApiConnectorConfigurationsByIdGetAsync(this IApiClient operations, System.Guid id, string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiConnectorConfigurationsByIdGetWithHttpMessagesAsync(id, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Get all connectors for the given clientId across all tenants
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static IList<ConnectorConfigModel> ApiConnectorConfigurationsGet(this IApiClient operations, string acceptLanguage = default(string))
            {
                return operations.ApiConnectorConfigurationsGetAsync(acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Get all connectors for the given clientId across all tenants
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<ConnectorConfigModel>> ApiConnectorConfigurationsGetAsync(this IApiClient operations, string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiConnectorConfigurationsGetWithHttpMessagesAsync(acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Gets a collection of items that match a single metadata field value.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fieldName'>
            /// The name of the metadata field.
            /// </param>
            /// <param name='fieldValue'>
            /// The required value of the metadata field.
            /// </param>
            /// <param name='pagesize'>
            /// The maximum number of items to return.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static IList<ItemSubmissionOutputModel> ApiItemsByFieldNameByFieldValueGet(this IApiClient operations, string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string))
            {
                return operations.ApiItemsByFieldNameByFieldValueGetAsync(fieldName, fieldValue, pagesize, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets a collection of items that match a single metadata field value.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='fieldName'>
            /// The name of the metadata field.
            /// </param>
            /// <param name='fieldValue'>
            /// The required value of the metadata field.
            /// </param>
            /// <param name='pagesize'>
            /// The maximum number of items to return.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<ItemSubmissionOutputModel>> ApiItemsByFieldNameByFieldValueGetAsync(this IApiClient operations, string fieldName, string fieldValue, int? pagesize = default(int?), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiItemsByFieldNameByFieldValueGetWithHttpMessagesAsync(fieldName, fieldValue, pagesize, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Submits an item to be managed by Records365 vNext.
            /// All records are to be submitted to this endpoint.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='item'>
            /// The item to be managed.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static object ApiItemsPost(this IApiClient operations, ItemSubmissionInputModel item = default(ItemSubmissionInputModel), string acceptLanguage = default(string))
            {
                return operations.ApiItemsPostAsync(item, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Submits an item to be managed by Records365 vNext.
            /// All records are to be submitted to this endpoint.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='item'>
            /// The item to be managed.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<object> ApiItemsPostAsync(this IApiClient operations, ItemSubmissionInputModel item = default(ItemSubmissionInputModel), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiItemsPostWithHttpMessagesAsync(item, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Gets a collection of notifications that are awaiting processing and
            /// acknowledgement by the connector.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='connectorId'>
            /// The query information
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static IList<ConnectorNotificationModel> ApiNotificationsByConnectorIdGet(this IApiClient operations, string connectorId, string acceptLanguage = default(string))
            {
                return operations.ApiNotificationsByConnectorIdGetAsync(connectorId, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets a collection of notifications that are awaiting processing and
            /// acknowledgement by the connector.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='connectorId'>
            /// The query information
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<IList<ConnectorNotificationModel>> ApiNotificationsByConnectorIdGetAsync(this IApiClient operations, string connectorId, string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiNotificationsByConnectorIdGetWithHttpMessagesAsync(connectorId, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Acknowledges a notification as having been processed by the connector.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='acknowledge'>
            /// The acknowledgement information.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            public static ErrorResponseModel ApiNotificationsPost(this IApiClient operations, ConnectorNotificationAcknowledgeModel acknowledge = default(ConnectorNotificationAcknowledgeModel), string acceptLanguage = default(string))
            {
                return operations.ApiNotificationsPostAsync(acknowledge, acceptLanguage).GetAwaiter().GetResult();
            }

            /// <summary>
            /// Acknowledges a notification as having been processed by the connector.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='acknowledge'>
            /// The acknowledgement information.
            /// </param>
            /// <param name='acceptLanguage'>
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<ErrorResponseModel> ApiNotificationsPostAsync(this IApiClient operations, ConnectorNotificationAcknowledgeModel acknowledge = default(ConnectorNotificationAcknowledgeModel), string acceptLanguage = default(string), CancellationToken cancellationToken = default(CancellationToken))
            {
                using (var _result = await operations.ApiNotificationsPostWithHttpMessagesAsync(acknowledge, acceptLanguage, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Represents a single metadata entry.
    /// </summary>
    public partial class MetaDataModel
    {
        /// <summary>
        /// Initializes a new instance of the MetaDataModel class.
        /// </summary>
        public MetaDataModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the MetaDataModel class.
        /// </summary>
        /// <param name="name">Internal name for the field</param>
        /// <param name="type">Type of the metadata entry.</param>
        /// <param name="value">Value of the metadata entry.</param>
        public MetaDataModel(string name, string type = default(string), string value = default(string))
        {
            Name = name;
            Type = type;
            Value = value;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets internal name for the field
        /// </summary>
        [JsonProperty(PropertyName = "name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets type of the metadata entry.
        /// </summary>
        [JsonProperty(PropertyName = "type")]
        public string Type { get; set; }

        /// <summary>
        /// Gets or sets value of the metadata entry.
        /// </summary>
        [JsonProperty(PropertyName = "value")]
        public string Value { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Name == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Name");
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class AggregationSubmissionOutputModel
    {
        /// <summary>
        /// Initializes a new instance of the AggregationSubmissionOutputModel
        /// class.
        /// </summary>
        public AggregationSubmissionOutputModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the AggregationSubmissionOutputModel
        /// class.
        /// </summary>
        /// <param name="externalId">The unique identifier of the aggregation
        /// in the content source</param>
        /// <param name="connectorId">Id of the Connector that created the
        /// aggregation</param>
        /// <param name="title">The title of the aggregation in the content
        /// source</param>
        /// <param name="sourceLastModifiedDate">The date and time when the
        /// aggregation was last modified in the content source. Must be in UTC
        /// and ISO-8601 Round-trip format</param>
        /// <param name="sourceLastModifiedBy">The name of the user or
        /// principal who last modified the aggregation in the content
        /// source</param>
        /// <param name="sourceCreatedDate">The date and time when the
        /// aggregation was created in the content source. Must be in UTC and
        /// ISO-8601 Round-trip format</param>
        /// <param name="sourceCreatedBy">The name of the user or principal who
        /// created the aggregation in the content source</param>
        /// <param name="id">Internal unique ID for the aggregation</param>
        /// <param name="itemType">The item type that corresponds to an
        /// aggregation</param>
        /// <param name="itemNumber">The record number, format that corresponds
        /// to an aggreagtion</param>
        /// <param name="createdDate">The date and time of when the aggregation
        /// was created in Records365 vNext</param>
        /// <param name="createdBy">Name of the user or principal that created
        /// the aggregation</param>
        /// <param name="lastModifiedDate">The date and time of when the
        /// aggregation was modified in Records365 vNext</param>
        /// <param name="lastModifiedBy">Name of the user or principal that
        /// last modified the aggregation</param>
        /// <param name="contentSource">The name of the content source of the
        /// Connector that created the aggregation</param>
        /// <param name="isVitalRecord">True if the aggregation is a vital
        /// record, false otherwise</param>
        /// <param name="sourceProperties">Source properties for the
        /// aggregation as populated from the content source</param>
        /// <param name="author">Used for Physical item aggregations</param>
        /// <param name="location">A pointer to a aggregation's location.
        /// For example, the operating system path name or the location of a
        /// file cabinet</param>
        /// <param name="mediaType">The media type, if set to empty, then the
        /// media type will default to "Electronic"</param>
        /// <param name="barcodeType">The barcode type e.g. code 128, qr
        /// code</param>
        /// <param name="barcodeValue">The barcode value of the above barcode
        /// type</param>
        /// <param name="recordCategoryId">The Record Category Id assigned by
        /// manual classification</param>
        public AggregationSubmissionOutputModel(string externalId, string connectorId, string title, System.DateTime sourceLastModifiedDate, string sourceLastModifiedBy, System.DateTime sourceCreatedDate, string sourceCreatedBy, string id = default(string), string itemType = default(string), string itemNumber = default(string), System.DateTime? createdDate = default(System.DateTime?), string createdBy = default(string), System.DateTime? lastModifiedDate = default(System.DateTime?), string lastModifiedBy = default(string), string contentSource = default(string), bool? isVitalRecord = default(bool?), IList<MetaDataModel> sourceProperties = default(IList<MetaDataModel>), string author = default(string), string location = default(string), string mediaType = default(string), string barcodeType = default(string), string barcodeValue = default(string), string recordCategoryId = default(string))
        {
            Id = id;
            ItemType = itemType;
            ItemNumber = itemNumber;
            CreatedDate = createdDate;
            CreatedBy = createdBy;
            LastModifiedDate = lastModifiedDate;
            LastModifiedBy = lastModifiedBy;
            ContentSource = contentSource;
            IsVitalRecord = isVitalRecord;
            SourceProperties = sourceProperties;
            ExternalId = externalId;
            ConnectorId = connectorId;
            Title = title;
            Author = author;
            SourceLastModifiedDate = sourceLastModifiedDate;
            SourceLastModifiedBy = sourceLastModifiedBy;
            SourceCreatedDate = sourceCreatedDate;
            SourceCreatedBy = sourceCreatedBy;
            Location = location;
            MediaType = mediaType;
            BarcodeType = barcodeType;
            BarcodeValue = barcodeValue;
            RecordCategoryId = recordCategoryId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets internal unique ID for the aggregation
        /// </summary>
        [JsonProperty(PropertyName = "id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or sets the item type that corresponds to an aggregation
        /// </summary>
        [JsonProperty(PropertyName = "itemType")]
        public string ItemType { get; set; }

        /// <summary>
        /// Gets or sets the record number, format that corresponds to an
        /// aggreagtion
        /// </summary>
        [JsonProperty(PropertyName = "itemNumber")]
        public string ItemNumber { get; set; }

        /// <summary>
        /// Gets or sets the date and time of when the aggregation was created
        /// in Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "createdDate")]
        public System.DateTime? CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets name of the user or principal that created the
        /// aggregation
        /// </summary>
        [JsonProperty(PropertyName = "createdBy")]
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time of when the aggregation was modified
        /// in Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "lastModifiedDate")]
        public System.DateTime? LastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets name of the user or principal that last modified the
        /// aggregation
        /// </summary>
        [JsonProperty(PropertyName = "lastModifiedBy")]
        public string LastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the name of the content source of the Connector that
        /// created the aggregation
        /// </summary>
        [JsonProperty(PropertyName = "contentSource")]
        public string ContentSource { get; set; }

        /// <summary>
        /// Gets or sets true if the aggregation is a vital record, false
        /// otherwise
        /// </summary>
        [JsonProperty(PropertyName = "isVitalRecord")]
        public bool? IsVitalRecord { get; set; }

        /// <summary>
        /// Gets or sets source properties for the aggregation as populated
        /// from the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceProperties")]
        public IList<MetaDataModel> SourceProperties { get; set; }

        /// <summary>
        /// Gets or sets the unique identifier of the aggregation in the
        /// content source
        /// </summary>
        [JsonProperty(PropertyName = "externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Gets or sets id of the Connector that created the aggregation
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the title of the aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "title")]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets used for Physical item aggregations
        /// </summary>
        [JsonProperty(PropertyName = "author")]
        public string Author { get; set; }

        /// <summary>
        /// Gets or sets the date and time when the aggregation was last
        /// modified in the content source. Must be in UTC and ISO-8601
        /// Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedDate")]
        public System.DateTime SourceLastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal who last modified
        /// the aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedBy")]
        public string SourceLastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time when the aggregation was created in
        /// the content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedDate")]
        public System.DateTime SourceCreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal who created the
        /// aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedBy")]
        public string SourceCreatedBy { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a aggregation's location.
        /// For example, the operating system path name or the location of a
        /// file cabinet
        /// </summary>
        [JsonProperty(PropertyName = "location")]
        public string Location { get; set; }

        /// <summary>
        /// Gets or sets the media type, if set to empty, then the media type
        /// will default to "Electronic"
        /// </summary>
        [JsonProperty(PropertyName = "mediaType")]
        public string MediaType { get; set; }

        /// <summary>
        /// Gets or sets the barcode type e.g. code 128, qr code
        /// </summary>
        [JsonProperty(PropertyName = "barcodeType")]
        public string BarcodeType { get; set; }

        /// <summary>
        /// Gets or sets the barcode value of the above barcode type
        /// </summary>
        [JsonProperty(PropertyName = "barcodeValue")]
        public string BarcodeValue { get; set; }

        /// <summary>
        /// Gets or sets the Record Category Id assigned by manual
        /// classification
        /// </summary>
        [JsonProperty(PropertyName = "recordCategoryId")]
        public string RecordCategoryId { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ExternalId");
            }
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (Title == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Title");
            }
            if (SourceLastModifiedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceLastModifiedBy");
            }
            if (SourceCreatedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceCreatedBy");
            }
            if (SourceProperties != null)
            {
                foreach (var element in SourceProperties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class SubmissionMetaDataModel
    {
        /// <summary>
        /// Initializes a new instance of the SubmissionMetaDataModel class.
        /// </summary>
        public SubmissionMetaDataModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the SubmissionMetaDataModel class.
        /// </summary>
        /// <param name="name">Internal name for the field</param>
        /// <param name="displayName">Display name for the field</param>
        /// <param name="type">Type of the metadata entry.</param>
        /// <param name="value">Value of the metadata entry.</param>
        public SubmissionMetaDataModel(string name, string displayName = default(string), string type = default(string), string value = default(string))
        {
            DisplayName = displayName;
            Name = name;
            Type = type;
            Value = value;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets display name for the field
        /// </summary>
        [JsonProperty(PropertyName = "displayName")]
        public string DisplayName { get; set; }

        /// <summary>
        /// Gets or sets internal name for the field
        /// </summary>
        [JsonProperty(PropertyName = "name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets type of the metadata entry.
        /// </summary>
        [JsonProperty(PropertyName = "type")]
        public string Type { get; set; }

        /// <summary>
        /// Gets or sets value of the metadata entry.
        /// </summary>
        [JsonProperty(PropertyName = "value")]
        public string Value { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Name == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Name");
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class AggregationSubmissionInputModel
    {
        /// <summary>
        /// Initializes a new instance of the AggregationSubmissionInputModel
        /// class.
        /// </summary>
        public AggregationSubmissionInputModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the AggregationSubmissionInputModel
        /// class.
        /// </summary>
        /// <param name="externalId">The unique identifier of the aggregation
        /// in the content source</param>
        /// <param name="connectorId">Id of the Connector that created the
        /// aggregation</param>
        /// <param name="title">The title of the aggregation in the content
        /// source</param>
        /// <param name="sourceLastModifiedDate">The date and time when the
        /// aggregation was last modified in the content source. Must be in UTC
        /// and ISO-8601 Round-trip format</param>
        /// <param name="sourceLastModifiedBy">The name of the user or
        /// principal who last modified the aggregation in the content
        /// source</param>
        /// <param name="sourceCreatedDate">The date and time when the
        /// aggregation was created in the content source. Must be in UTC and
        /// ISO-8601 Round-trip format</param>
        /// <param name="sourceCreatedBy">The name of the user or principal who
        /// created the aggregation in the content source</param>
        /// <param name="itemTypeId">The item type ID that corresponds to an
        /// aggregation</param>
        /// <param name="sourceProperties">Source properties for the
        /// aggregation with DisplayName</param>
        /// <param name="author">Used for Physical item aggregations</param>
        /// <param name="location">A pointer to a aggregation's location.
        /// For example, the operating system path name or the location of a
        /// file cabinet</param>
        /// <param name="mediaType">The media type, if set to empty, then the
        /// media type will default to "Electronic"</param>
        /// <param name="barcodeType">The barcode type e.g. code 128, qr
        /// code</param>
        /// <param name="barcodeValue">The barcode value of the above barcode
        /// type</param>
        /// <param name="recordCategoryId">The Record Category Id assigned by
        /// manual classification</param>
        public AggregationSubmissionInputModel(string externalId, string connectorId, string title, System.DateTime sourceLastModifiedDate, string sourceLastModifiedBy, System.DateTime sourceCreatedDate, string sourceCreatedBy, int? itemTypeId = default(int?), IList<SubmissionMetaDataModel> sourceProperties = default(IList<SubmissionMetaDataModel>), string author = default(string), string location = default(string), string mediaType = default(string), string barcodeType = default(string), string barcodeValue = default(string), string recordCategoryId = default(string))
        {
            ItemTypeId = itemTypeId;
            SourceProperties = sourceProperties;
            ExternalId = externalId;
            ConnectorId = connectorId;
            Title = title;
            Author = author;
            SourceLastModifiedDate = sourceLastModifiedDate;
            SourceLastModifiedBy = sourceLastModifiedBy;
            SourceCreatedDate = sourceCreatedDate;
            SourceCreatedBy = sourceCreatedBy;
            Location = location;
            MediaType = mediaType;
            BarcodeType = barcodeType;
            BarcodeValue = barcodeValue;
            RecordCategoryId = recordCategoryId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets the item type ID that corresponds to an aggregation
        /// </summary>
        [JsonProperty(PropertyName = "itemTypeId")]
        public int? ItemTypeId { get; set; }

        /// <summary>
        /// Gets or sets source properties for the aggregation with DisplayName
        /// </summary>
        [JsonProperty(PropertyName = "sourceProperties")]
        public IList<SubmissionMetaDataModel> SourceProperties { get; set; }

        /// <summary>
        /// Gets or sets the unique identifier of the aggregation in the
        /// content source
        /// </summary>
        [JsonProperty(PropertyName = "externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Gets or sets id of the Connector that created the aggregation
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the title of the aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "title")]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets used for Physical item aggregations
        /// </summary>
        [JsonProperty(PropertyName = "author")]
        public string Author { get; set; }

        /// <summary>
        /// Gets or sets the date and time when the aggregation was last
        /// modified in the content source. Must be in UTC and ISO-8601
        /// Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedDate")]
        public System.DateTime SourceLastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal who last modified
        /// the aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedBy")]
        public string SourceLastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time when the aggregation was created in
        /// the content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedDate")]
        public System.DateTime SourceCreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal who created the
        /// aggregation in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedBy")]
        public string SourceCreatedBy { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a aggregation's location.
        /// For example, the operating system path name or the location of a
        /// file cabinet
        /// </summary>
        [JsonProperty(PropertyName = "location")]
        public string Location { get; set; }

        /// <summary>
        /// Gets or sets the media type, if set to empty, then the media type
        /// will default to "Electronic"
        /// </summary>
        [JsonProperty(PropertyName = "mediaType")]
        public string MediaType { get; set; }

        /// <summary>
        /// Gets or sets the barcode type e.g. code 128, qr code
        /// </summary>
        [JsonProperty(PropertyName = "barcodeType")]
        public string BarcodeType { get; set; }

        /// <summary>
        /// Gets or sets the barcode value of the above barcode type
        /// </summary>
        [JsonProperty(PropertyName = "barcodeValue")]
        public string BarcodeValue { get; set; }

        /// <summary>
        /// Gets or sets the Record Category Id assigned by manual
        /// classification
        /// </summary>
        [JsonProperty(PropertyName = "recordCategoryId")]
        public string RecordCategoryId { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ExternalId");
            }
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (Title == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Title");
            }
            if (SourceLastModifiedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceLastModifiedBy");
            }
            if (SourceCreatedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceCreatedBy");
            }
            if (SourceProperties != null)
            {
                foreach (var element in SourceProperties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Error object.
    /// Defined by Microsoft REST API design guidelines:
    /// https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#710-response-formats
    /// </summary>
    public partial class ErrorModel
    {
        /// <summary>
        /// Initializes a new instance of the ErrorModel class.
        /// </summary>
        public ErrorModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ErrorModel class.
        /// </summary>
        /// <param name="type">Possible values include: 'general', 'aggregate',
        /// 'validation', 'partialSuccess'</param>
        /// <param name="severity">Possible values include: 'critical',
        /// 'error', 'warning', 'informational'</param>
        public ErrorModel(string type = default(string), string message = default(string), string messageCode = default(string), string severity = default(string), System.DateTime? dateTime = default(System.DateTime?), string target = default(string), IList<ErrorModel> innerError = default(IList<ErrorModel>))
        {
            Type = type;
            Message = message;
            MessageCode = messageCode;
            Severity = severity;
            DateTime = dateTime;
            Target = target;
            InnerError = innerError;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets possible values include: 'general', 'aggregate',
        /// 'validation', 'partialSuccess'
        /// </summary>
        [JsonProperty(PropertyName = "type")]
        public string Type { get; set; }

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "message")]
        public string Message { get; set; }

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "messageCode")]
        public string MessageCode { get; set; }

        /// <summary>
        /// Gets or sets possible values include: 'critical', 'error',
        /// 'warning', 'informational'
        /// </summary>
        [JsonProperty(PropertyName = "severity")]
        public string Severity { get; set; }

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "dateTime")]
        public System.DateTime? DateTime { get; set; }

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "target")]
        public string Target { get; set; }

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "innerError")]
        public IList<ErrorModel> InnerError { get; set; }

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Top level error response object.
    /// Defined by Microsoft REST API design guidelines:
    /// https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#710-response-formats
    /// </summary>
    public partial class ErrorResponseModel
    {
        /// <summary>
        /// Initializes a new instance of the ErrorResponseModel class.
        /// </summary>
        public ErrorResponseModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ErrorResponseModel class.
        /// </summary>
        public ErrorResponseModel(ErrorModel error = default(ErrorModel))
        {
            Error = error;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// </summary>
        [JsonProperty(PropertyName = "error")]
        public ErrorModel Error { get; set; }

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Represents an audit event in a content source.
    /// </summary>
    public partial class ConnectorAuditEventModel
    {
        /// <summary>
        /// Initializes a new instance of the ConnectorAuditEventModel class.
        /// </summary>
        public ConnectorAuditEventModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ConnectorAuditEventModel class.
        /// </summary>
        /// <param name="eventExternalId">The ID of the audit event in the
        /// content source</param>
        /// <param name="connectorId">The connector ID. Unique ID of the
        /// submitting connector</param>
        /// <param name="eventType">The type of event being audited</param>
        /// <param name="itemExternalId">The external ID of the item that this
        /// audit event relates to</param>
        /// <param name="createdDate">The date and time when the audit event
        /// was created / action was performed. Must be in UTC and ISO-8601
        /// Round-trip format</param>
        /// <param name="description">Description of the event being
        /// audited</param>
        /// <param name="userId">ID of the user that executed the event being
        /// audited</param>
        /// <param name="userName">Username of the user that executed the event
        /// being audited</param>
        /// <param name="sourceProperties">List of auditing properties specific
        /// to the content source where the event was originated</param>
        public ConnectorAuditEventModel(string eventExternalId, string connectorId, string eventType, string itemExternalId, System.DateTime? createdDate = default(System.DateTime?), string description = default(string), string userId = default(string), string userName = default(string), IList<SubmissionMetaDataModel> sourceProperties = default(IList<SubmissionMetaDataModel>))
        {
            EventExternalId = eventExternalId;
            ConnectorId = connectorId;
            CreatedDate = createdDate;
            EventType = eventType;
            Description = description;
            UserId = userId;
            UserName = userName;
            ItemExternalId = itemExternalId;
            SourceProperties = sourceProperties;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets the ID of the audit event in the content source
        /// </summary>
        [JsonProperty(PropertyName = "eventExternalId")]
        public string EventExternalId { get; set; }

        /// <summary>
        /// Gets or sets the connector ID. Unique ID of the submitting
        /// connector
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the date and time when the audit event was created /
        /// action was performed. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "createdDate")]
        public System.DateTime? CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the type of event being audited
        /// </summary>
        [JsonProperty(PropertyName = "eventType")]
        public string EventType { get; set; }

        /// <summary>
        /// Gets or sets description of the event being audited
        /// </summary>
        [JsonProperty(PropertyName = "description")]
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets ID of the user that executed the event being audited
        /// </summary>
        [JsonProperty(PropertyName = "userId")]
        public string UserId { get; set; }

        /// <summary>
        /// Gets or sets username of the user that executed the event being
        /// audited
        /// </summary>
        [JsonProperty(PropertyName = "userName")]
        public string UserName { get; set; }

        /// <summary>
        /// Gets or sets the external ID of the item that this audit event
        /// relates to
        /// </summary>
        [JsonProperty(PropertyName = "itemExternalId")]
        public string ItemExternalId { get; set; }

        /// <summary>
        /// Gets or sets list of auditing properties specific to the content
        /// source where the event was originated
        /// </summary>
        [JsonProperty(PropertyName = "sourceProperties")]
        public IList<SubmissionMetaDataModel> SourceProperties { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (EventExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "EventExternalId");
            }
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (EventType == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "EventType");
            }
            if (ItemExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ItemExternalId");
            }
            if (EventType != null)
            {
                if (EventType.Length > 255)
                {
                    throw new ValidationException(ValidationRules.MaxLength, "EventType", 255);
                }
                if (EventType.Length < 0)
                {
                    throw new ValidationException(ValidationRules.MinLength, "EventType", 0);
                }
            }
            if (SourceProperties != null)
            {
                foreach (var element in SourceProperties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Connector configuration.
    /// Connector configuration models are designed to be "one size fits all",
    /// that is, this model schema is designed to be able to be used for all
    /// connector types.
    /// </summary>
    public partial class ConnectorConfigModel
    {
        /// <summary>
        /// Initializes a new instance of the ConnectorConfigModel class.
        /// </summary>
        public ConnectorConfigModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ConnectorConfigModel class.
        /// </summary>
        /// <param name="status">"Enabled" if the connector is enabled,
        /// "Disabled" if disabled,
        /// "Error" if in error state
        /// Must be set to "Disabled" when connector is being created
        /// Can be set to "Enabled", if connector is authorized in content
        /// source
        /// and aggregation level and versioning level are provided</param>
        /// <param name="displayName">The display name for this connector
        /// instance</param>
        /// <param name="hasSubmittedData">Whether the connector has submitted
        /// any items</param>
        /// <param name="id">ID of this Connector instance</param>
        /// <param name="transactionId">Current Transaction ID on this
        /// object</param>
        /// <param name="connectorTypeId">ID of the ConnectorType for this
        /// instance</param>
        /// <param name="statusCode">String containing general reason for last
        /// connector error state</param>
        /// <param name="createdDate">Date and time that this connector
        /// instance was created</param>
        /// <param name="modifiedDate">Date and time that this connector
        /// instance was last modified</param>
        /// <param name="createdBy">Username of the user that created this
        /// connector instance</param>
        /// <param name="modifiedBy">Username of the user that last modified
        /// this connector instance</param>
        /// <param name="tenantId">The ID of the Records365 vNext tenant that
        /// owns this connector instance</param>
        /// <param name="tenantDomainName">The domain name of the Records365
        /// vNext tenant that owns this connector instance</param>
        /// <param name="originatingOrganization">Originating organization
        /// field to map with the name of the organization the connector is
        /// connecting to</param>
        /// <param name="enabledHistory">True if this connector has ever been
        /// enabled in its lifetime, false otherwise. This is a read-only
        /// property</param>
        /// <param name="properties">Custom properties for the connector
        /// instance</param>
        /// <param name="clientId">Client ID of the OAuth 2.0 Application
        /// (e.g.,
        /// an Azure AD Application) that represents this Connector.
        /// Is used instead of the Connector Type's Client ID if
        /// present</param>
        public ConnectorConfigModel(string status, string displayName, bool hasSubmittedData, string id = default(string), string transactionId = default(string), string connectorTypeId = default(string), string statusCode = default(string), System.DateTime? createdDate = default(System.DateTime?), System.DateTime? modifiedDate = default(System.DateTime?), string createdBy = default(string), string modifiedBy = default(string), string tenantId = default(string), string tenantDomainName = default(string), string originatingOrganization = default(string), string enabledHistory = default(string), IList<MetaDataModel> properties = default(IList<MetaDataModel>), string clientId = default(string))
        {
            Id = id;
            TransactionId = transactionId;
            ConnectorTypeId = connectorTypeId;
            Status = status;
            StatusCode = statusCode;
            CreatedDate = createdDate;
            ModifiedDate = modifiedDate;
            CreatedBy = createdBy;
            ModifiedBy = modifiedBy;
            TenantId = tenantId;
            TenantDomainName = tenantDomainName;
            OriginatingOrganization = originatingOrganization;
            EnabledHistory = enabledHistory;
            DisplayName = displayName;
            HasSubmittedData = hasSubmittedData;
            Properties = properties;
            ClientId = clientId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets ID of this Connector instance
        /// </summary>
        [JsonProperty(PropertyName = "id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or sets current Transaction ID on this object
        /// </summary>
        [JsonProperty(PropertyName = "transactionId")]
        public string TransactionId { get; set; }

        /// <summary>
        /// Gets or sets ID of the ConnectorType for this instance
        /// </summary>
        [JsonProperty(PropertyName = "connectorTypeId")]
        public string ConnectorTypeId { get; set; }

        /// <summary>
        /// Gets or sets "Enabled" if the connector is enabled, "Disabled" if
        /// disabled,
        /// "Error" if in error state
        /// Must be set to "Disabled" when connector is being created
        /// Can be set to "Enabled", if connector is authorized in content
        /// source
        /// and aggregation level and versioning level are provided
        /// </summary>
        [JsonProperty(PropertyName = "status")]
        public string Status { get; set; }

        /// <summary>
        /// Gets or sets string containing general reason for last connector
        /// error state
        /// </summary>
        [JsonProperty(PropertyName = "statusCode")]
        public string StatusCode { get; set; }

        /// <summary>
        /// Gets or sets date and time that this connector instance was created
        /// </summary>
        [JsonProperty(PropertyName = "createdDate")]
        public System.DateTime? CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets date and time that this connector instance was last
        /// modified
        /// </summary>
        [JsonProperty(PropertyName = "modifiedDate")]
        public System.DateTime? ModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets username of the user that created this connector
        /// instance
        /// </summary>
        [JsonProperty(PropertyName = "createdBy")]
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets username of the user that last modified this connector
        /// instance
        /// </summary>
        [JsonProperty(PropertyName = "modifiedBy")]
        public string ModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the ID of the Records365 vNext tenant that owns this
        /// connector instance
        /// </summary>
        [JsonProperty(PropertyName = "tenantId")]
        public string TenantId { get; set; }

        /// <summary>
        /// Gets or sets the domain name of the Records365 vNext tenant that
        /// owns this connector instance
        /// </summary>
        [JsonProperty(PropertyName = "tenantDomainName")]
        public string TenantDomainName { get; set; }

        /// <summary>
        /// Gets or sets originating organization field to map with the name of
        /// the organization the connector is connecting to
        /// </summary>
        [JsonProperty(PropertyName = "originatingOrganization")]
        public string OriginatingOrganization { get; set; }

        /// <summary>
        /// Gets or sets true if this connector has ever been enabled in its
        /// lifetime, false otherwise. This is a read-only property
        /// </summary>
        [JsonProperty(PropertyName = "enabledHistory")]
        public string EnabledHistory { get; set; }

        /// <summary>
        /// Gets or sets the display name for this connector instance
        /// </summary>
        [JsonProperty(PropertyName = "displayName")]
        public string DisplayName { get; set; }

        /// <summary>
        /// Gets or sets whether the connector has submitted any items
        /// </summary>
        [JsonProperty(PropertyName = "hasSubmittedData")]
        public bool HasSubmittedData { get; set; }

        /// <summary>
        /// Gets or sets custom properties for the connector instance
        /// </summary>
        [JsonProperty(PropertyName = "properties")]
        public IList<MetaDataModel> Properties { get; set; }

        /// <summary>
        /// Gets or sets client ID of the OAuth 2.0 Application (e.g.,
        /// an Azure AD Application) that represents this Connector.
        /// Is used instead of the Connector Type's Client ID if present
        /// </summary>
        [JsonProperty(PropertyName = "clientId")]
        public string ClientId { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Status == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Status");
            }
            if (DisplayName == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "DisplayName");
            }
            if (DisplayName != null)
            {
                if (DisplayName.Length > 255)
                {
                    throw new ValidationException(ValidationRules.MaxLength, "DisplayName", 255);
                }
                if (DisplayName.Length < 0)
                {
                    throw new ValidationException(ValidationRules.MinLength, "DisplayName", 0);
                }
            }
            if (Properties != null)
            {
                foreach (var element in Properties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class ItemSubmissionOutputModel
    {
        /// <summary>
        /// Initializes a new instance of the ItemSubmissionOutputModel class.
        /// </summary>
        public ItemSubmissionOutputModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ItemSubmissionOutputModel class.
        /// </summary>
        /// <param name="externalId">The item external ID. This can be
        /// anything, but make sure it's unique to the external content
        /// source</param>
        /// <param name="connectorId">The connector ID. Unique ID of the
        /// submitting connector</param>
        /// <param name="title">The title of the submitted item</param>
        /// <param name="author">The person, office, or designated position
        /// responsible for creation or issuance of a document.
        /// The author, originator, or creator is usually indicated on the
        /// letterhead or by signature.
        /// For RMA purposes, the author, originator, or creator may be
        /// designated as a person, official title, office symbol, or
        /// code</param>
        /// <param name="sourceLastModifiedDate">The date and time that the
        /// item was last modified in the content source. Must be in UTC and
        /// ISO-8601 Round-trip format</param>
        /// <param name="sourceLastModifiedBy">The name of the user or
        /// principal that last modified the item in the content source</param>
        /// <param name="sourceCreatedBy">The name of the user or principal
        /// that created the item in the content source</param>
        /// <param name="sourceCreatedDate">The date and time that the item was
        /// created in the content source. Must be in UTC and ISO-8601
        /// Round-trip format</param>
        /// <param name="contentVersion">The version as stored in the content
        /// source</param>
        /// <param name="location">A pointer to a record???s location.
        /// Examples: an operating system path and filename, the location cited
        /// within a file plan, or the location of a magnetic tape rack</param>
        /// <param name="mediaType">The media type, if set to empty, then the
        /// media type will default to "Electronic"</param>
        /// <param name="parentExternalId">A pointer to a record???s
        /// aggregation</param>
        /// <param name="id">Internal unique ID for the item</param>
        /// <param name="itemType">Defines the type of the item</param>
        /// <param name="itemNumber">The internal Records365 vNext item number
        /// given to the submitted item</param>
        /// <param name="format">The mime format of the submitted item as
        /// determined from the file extension</param>
        /// <param name="lastModifiedDate">The date and time of when the item
        /// was last modified in Records365 vNext</param>
        /// <param name="lastModifiedBy">The identifier of who or what last
        /// modified the item in Records365 vNext</param>
        /// <param name="createdDate">The date and time of when the item was
        /// created in Records365 vNext</param>
        /// <param name="createdBy">The identifier of who or what created the
        /// record in Records365 vNext</param>
        /// <param name="contentSource">The name of content source from which
        /// the item was submitted</param>
        /// <param name="connectorDisplayName">The name of the connector that
        /// submitted the item</param>
        /// <param name="isVitalRecord">True if the item is a vital record,
        /// false otherwise</param>
        /// <param name="originatingOrganization">The name of the organization
        /// that submitted the item</param>
        /// <param name="previousDisposalAction">Previous disposal action taken
        /// on this item</param>
        /// <param name="previousDisposalDate">Date of when the previous
        /// disposal action was taken on this item</param>
        /// <param name="previousDisposalBy">The user name of the user who
        /// completed the last disposal action</param>
        /// <param name="previousDisposalById">For auditing purposes, the ID of
        /// the user who completed the last disposal action</param>
        /// <param name="nextDisposalAction">Next disposition phase action to
        /// be taken on this item</param>
        /// <param name="nextDisposalDate">Next disposition phase action
        /// date</param>
        /// <param name="currentDisposalStatus">The current disposal status of
        /// the item, e.g. "Destroyed", "Disposal In-Progress", "Error"
        /// etc</param>
        /// <param name="sourceProperties">Source properties for the item as
        /// populated from the content source</param>
        /// <param name="correlationId">An ID to be used to correlate an item
        /// with events in Records365 vNext</param>
        /// <param name="mimeType">The mime type of the submitted item</param>
        /// <param name="barcodeType">The barcode type, this can be
        /// empty</param>
        /// <param name="barcodeValue">The barcode value of the above barcode
        /// type</param>
        public ItemSubmissionOutputModel(string externalId, string connectorId, string title, string author, System.DateTime sourceLastModifiedDate, string sourceLastModifiedBy, string sourceCreatedBy, System.DateTime sourceCreatedDate, string contentVersion, string location, string mediaType, string parentExternalId, string id = default(string), string itemType = default(string), string itemNumber = default(string), string format = default(string), System.DateTime? lastModifiedDate = default(System.DateTime?), string lastModifiedBy = default(string), System.DateTime? createdDate = default(System.DateTime?), string createdBy = default(string), string contentSource = default(string), string connectorDisplayName = default(string), bool? isVitalRecord = default(bool?), string originatingOrganization = default(string), string previousDisposalAction = default(string), System.DateTime? previousDisposalDate = default(System.DateTime?), string previousDisposalBy = default(string), string previousDisposalById = default(string), string nextDisposalAction = default(string), System.DateTime? nextDisposalDate = default(System.DateTime?), string currentDisposalStatus = default(string), IList<MetaDataModel> sourceProperties = default(IList<MetaDataModel>), string correlationId = default(string), string mimeType = default(string), string barcodeType = default(string), string barcodeValue = default(string))
        {
            Id = id;
            ItemType = itemType;
            ItemNumber = itemNumber;
            Format = format;
            LastModifiedDate = lastModifiedDate;
            LastModifiedBy = lastModifiedBy;
            CreatedDate = createdDate;
            CreatedBy = createdBy;
            ContentSource = contentSource;
            ConnectorDisplayName = connectorDisplayName;
            IsVitalRecord = isVitalRecord;
            OriginatingOrganization = originatingOrganization;
            PreviousDisposalAction = previousDisposalAction;
            PreviousDisposalDate = previousDisposalDate;
            PreviousDisposalBy = previousDisposalBy;
            PreviousDisposalById = previousDisposalById;
            NextDisposalAction = nextDisposalAction;
            NextDisposalDate = nextDisposalDate;
            CurrentDisposalStatus = currentDisposalStatus;
            SourceProperties = sourceProperties;
            CorrelationId = correlationId;
            ExternalId = externalId;
            ConnectorId = connectorId;
            Title = title;
            Author = author;
            MimeType = mimeType;
            SourceLastModifiedDate = sourceLastModifiedDate;
            SourceLastModifiedBy = sourceLastModifiedBy;
            SourceCreatedBy = sourceCreatedBy;
            SourceCreatedDate = sourceCreatedDate;
            ContentVersion = contentVersion;
            Location = location;
            MediaType = mediaType;
            ParentExternalId = parentExternalId;
            BarcodeType = barcodeType;
            BarcodeValue = barcodeValue;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets internal unique ID for the item
        /// </summary>
        [JsonProperty(PropertyName = "id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or sets defines the type of the item
        /// </summary>
        [JsonProperty(PropertyName = "itemType")]
        public string ItemType { get; set; }

        /// <summary>
        /// Gets or sets the internal Records365 vNext item number given to the
        /// submitted item
        /// </summary>
        [JsonProperty(PropertyName = "itemNumber")]
        public string ItemNumber { get; set; }

        /// <summary>
        /// Gets or sets the mime format of the submitted item as determined
        /// from the file extension
        /// </summary>
        [JsonProperty(PropertyName = "format")]
        public string Format { get; set; }

        /// <summary>
        /// Gets or sets the date and time of when the item was last modified
        /// in Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "lastModifiedDate")]
        public System.DateTime? LastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets the identifier of who or what last modified the item
        /// in Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "lastModifiedBy")]
        public string LastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time of when the item was created in
        /// Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "createdDate")]
        public System.DateTime? CreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the identifier of who or what created the record in
        /// Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "createdBy")]
        public string CreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the name of content source from which the item was
        /// submitted
        /// </summary>
        [JsonProperty(PropertyName = "contentSource")]
        public string ContentSource { get; set; }

        /// <summary>
        /// Gets or sets the name of the connector that submitted the item
        /// </summary>
        [JsonProperty(PropertyName = "connectorDisplayName")]
        public string ConnectorDisplayName { get; set; }

        /// <summary>
        /// Gets or sets true if the item is a vital record, false otherwise
        /// </summary>
        [JsonProperty(PropertyName = "isVitalRecord")]
        public bool? IsVitalRecord { get; set; }

        /// <summary>
        /// Gets or sets the name of the organization that submitted the item
        /// </summary>
        [JsonProperty(PropertyName = "originatingOrganization")]
        public string OriginatingOrganization { get; set; }

        /// <summary>
        /// Gets or sets previous disposal action taken on this item
        /// </summary>
        [JsonProperty(PropertyName = "previousDisposalAction")]
        public string PreviousDisposalAction { get; set; }

        /// <summary>
        /// Gets or sets date of when the previous disposal action was taken on
        /// this item
        /// </summary>
        [JsonProperty(PropertyName = "previousDisposalDate")]
        public System.DateTime? PreviousDisposalDate { get; set; }

        /// <summary>
        /// Gets or sets the user name of the user who completed the last
        /// disposal action
        /// </summary>
        [JsonProperty(PropertyName = "previousDisposalBy")]
        public string PreviousDisposalBy { get; set; }

        /// <summary>
        /// Gets or sets for auditing purposes, the ID of the user who
        /// completed the last disposal action
        /// </summary>
        [JsonProperty(PropertyName = "previousDisposalById")]
        public string PreviousDisposalById { get; set; }

        /// <summary>
        /// Gets or sets next disposition phase action to be taken on this item
        /// </summary>
        [JsonProperty(PropertyName = "nextDisposalAction")]
        public string NextDisposalAction { get; set; }

        /// <summary>
        /// Gets or sets next disposition phase action date
        /// </summary>
        [JsonProperty(PropertyName = "nextDisposalDate")]
        public System.DateTime? NextDisposalDate { get; set; }

        /// <summary>
        /// Gets or sets the current disposal status of the item, e.g.
        /// "Destroyed", "Disposal In-Progress", "Error" etc
        /// </summary>
        [JsonProperty(PropertyName = "currentDisposalStatus")]
        public string CurrentDisposalStatus { get; set; }

        /// <summary>
        /// Gets or sets source properties for the item as populated from the
        /// content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceProperties")]
        public IList<MetaDataModel> SourceProperties { get; set; }

        /// <summary>
        /// Gets or sets an ID to be used to correlate an item with events in
        /// Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "correlationId")]
        public string CorrelationId { get; set; }

        /// <summary>
        /// Gets or sets the item external ID. This can be anything, but make
        /// sure it's unique to the external content source
        /// </summary>
        [JsonProperty(PropertyName = "externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Gets or sets the connector ID. Unique ID of the submitting
        /// connector
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the title of the submitted item
        /// </summary>
        [JsonProperty(PropertyName = "title")]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the person, office, or designated position responsible
        /// for creation or issuance of a document.
        /// The author, originator, or creator is usually indicated on the
        /// letterhead or by signature.
        /// For RMA purposes, the author, originator, or creator may be
        /// designated as a person, official title, office symbol, or code
        /// </summary>
        [JsonProperty(PropertyName = "author")]
        public string Author { get; set; }

        /// <summary>
        /// Gets or sets the mime type of the submitted item
        /// </summary>
        [JsonProperty(PropertyName = "mimeType")]
        public string MimeType { get; set; }

        /// <summary>
        /// Gets or sets the date and time that the item was last modified in
        /// the content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedDate")]
        public System.DateTime SourceLastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal that last modified
        /// the item in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedBy")]
        public string SourceLastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal that created the
        /// item in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedBy")]
        public string SourceCreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time that the item was created in the
        /// content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedDate")]
        public System.DateTime SourceCreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the version as stored in the content source
        /// </summary>
        [JsonProperty(PropertyName = "contentVersion")]
        public string ContentVersion { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a record???s location.
        /// Examples: an operating system path and filename, the location cited
        /// within a file plan, or the location of a magnetic tape rack
        /// </summary>
        [JsonProperty(PropertyName = "location")]
        public string Location { get; set; }

        /// <summary>
        /// Gets or sets the media type, if set to empty, then the media type
        /// will default to "Electronic"
        /// </summary>
        [JsonProperty(PropertyName = "mediaType")]
        public string MediaType { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a record???s aggregation
        /// </summary>
        [JsonProperty(PropertyName = "parentExternalId")]
        public string ParentExternalId { get; set; }

        /// <summary>
        /// Gets or sets the barcode type, this can be empty
        /// </summary>
        [JsonProperty(PropertyName = "barcodeType")]
        public string BarcodeType { get; set; }

        /// <summary>
        /// Gets or sets the barcode value of the above barcode type
        /// </summary>
        [JsonProperty(PropertyName = "barcodeValue")]
        public string BarcodeValue { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ExternalId");
            }
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (Title == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Title");
            }
            if (Author == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Author");
            }
            if (SourceLastModifiedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceLastModifiedBy");
            }
            if (SourceCreatedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceCreatedBy");
            }
            if (ContentVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ContentVersion");
            }
            if (Location == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Location");
            }
            if (MediaType == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "MediaType");
            }
            if (ParentExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ParentExternalId");
            }
            if (SourceProperties != null)
            {
                foreach (var element in SourceProperties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class ItemSubmissionInputModel
    {
        /// <summary>
        /// Initializes a new instance of the ItemSubmissionInputModel class.
        /// </summary>
        public ItemSubmissionInputModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ItemSubmissionInputModel class.
        /// </summary>
        /// <param name="externalId">The item external ID. This can be
        /// anything, but make sure it's unique to the external content
        /// source</param>
        /// <param name="connectorId">The connector ID. Unique ID of the
        /// submitting connector</param>
        /// <param name="title">The title of the submitted item</param>
        /// <param name="author">The person, office, or designated position
        /// responsible for creation or issuance of a document.
        /// The author, originator, or creator is usually indicated on the
        /// letterhead or by signature.
        /// For RMA purposes, the author, originator, or creator may be
        /// designated as a person, official title, office symbol, or
        /// code</param>
        /// <param name="sourceLastModifiedDate">The date and time that the
        /// item was last modified in the content source. Must be in UTC and
        /// ISO-8601 Round-trip format</param>
        /// <param name="sourceLastModifiedBy">The name of the user or
        /// principal that last modified the item in the content source</param>
        /// <param name="sourceCreatedBy">The name of the user or principal
        /// that created the item in the content source</param>
        /// <param name="sourceCreatedDate">The date and time that the item was
        /// created in the content source. Must be in UTC and ISO-8601
        /// Round-trip format</param>
        /// <param name="contentVersion">The version as stored in the content
        /// source</param>
        /// <param name="location">A pointer to a record???s location.
        /// Examples: an operating system path and filename, the location cited
        /// within a file plan, or the location of a magnetic tape rack</param>
        /// <param name="mediaType">The media type, if set to empty, then the
        /// media type will default to "Electronic"</param>
        /// <param name="parentExternalId">A pointer to a record???s
        /// aggregation</param>
        /// <param name="sourceProperties">The MetaDataModel list with
        /// DisplayName</param>
        /// <param name="mimeType">The mime type of the submitted item</param>
        /// <param name="barcodeType">The barcode type, this can be
        /// empty</param>
        /// <param name="barcodeValue">The barcode value of the above barcode
        /// type</param>
        public ItemSubmissionInputModel(string externalId, string connectorId, string title, string author, System.DateTime sourceLastModifiedDate, string sourceLastModifiedBy, string sourceCreatedBy, System.DateTime sourceCreatedDate, string contentVersion, string location, string mediaType, string parentExternalId, IList<SubmissionMetaDataModel> sourceProperties = default(IList<SubmissionMetaDataModel>), string mimeType = default(string), string barcodeType = default(string), string barcodeValue = default(string))
        {
            SourceProperties = sourceProperties;
            ExternalId = externalId;
            ConnectorId = connectorId;
            Title = title;
            Author = author;
            MimeType = mimeType;
            SourceLastModifiedDate = sourceLastModifiedDate;
            SourceLastModifiedBy = sourceLastModifiedBy;
            SourceCreatedBy = sourceCreatedBy;
            SourceCreatedDate = sourceCreatedDate;
            ContentVersion = contentVersion;
            Location = location;
            MediaType = mediaType;
            ParentExternalId = parentExternalId;
            BarcodeType = barcodeType;
            BarcodeValue = barcodeValue;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets the MetaDataModel list with DisplayName
        /// </summary>
        [JsonProperty(PropertyName = "sourceProperties")]
        public IList<SubmissionMetaDataModel> SourceProperties { get; set; }

        /// <summary>
        /// Gets or sets the item external ID. This can be anything, but make
        /// sure it's unique to the external content source
        /// </summary>
        [JsonProperty(PropertyName = "externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Gets or sets the connector ID. Unique ID of the submitting
        /// connector
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the title of the submitted item
        /// </summary>
        [JsonProperty(PropertyName = "title")]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the person, office, or designated position responsible
        /// for creation or issuance of a document.
        /// The author, originator, or creator is usually indicated on the
        /// letterhead or by signature.
        /// For RMA purposes, the author, originator, or creator may be
        /// designated as a person, official title, office symbol, or code
        /// </summary>
        [JsonProperty(PropertyName = "author")]
        public string Author { get; set; }

        /// <summary>
        /// Gets or sets the mime type of the submitted item
        /// </summary>
        [JsonProperty(PropertyName = "mimeType")]
        public string MimeType { get; set; }

        /// <summary>
        /// Gets or sets the date and time that the item was last modified in
        /// the content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedDate")]
        public System.DateTime SourceLastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal that last modified
        /// the item in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedBy")]
        public string SourceLastModifiedBy { get; set; }

        /// <summary>
        /// Gets or sets the name of the user or principal that created the
        /// item in the content source
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedBy")]
        public string SourceCreatedBy { get; set; }

        /// <summary>
        /// Gets or sets the date and time that the item was created in the
        /// content source. Must be in UTC and ISO-8601 Round-trip format
        /// </summary>
        [JsonProperty(PropertyName = "sourceCreatedDate")]
        public System.DateTime SourceCreatedDate { get; set; }

        /// <summary>
        /// Gets or sets the version as stored in the content source
        /// </summary>
        [JsonProperty(PropertyName = "contentVersion")]
        public string ContentVersion { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a record???s location.
        /// Examples: an operating system path and filename, the location cited
        /// within a file plan, or the location of a magnetic tape rack
        /// </summary>
        [JsonProperty(PropertyName = "location")]
        public string Location { get; set; }

        /// <summary>
        /// Gets or sets the media type, if set to empty, then the media type
        /// will default to "Electronic"
        /// </summary>
        [JsonProperty(PropertyName = "mediaType")]
        public string MediaType { get; set; }

        /// <summary>
        /// Gets or sets a pointer to a record???s aggregation
        /// </summary>
        [JsonProperty(PropertyName = "parentExternalId")]
        public string ParentExternalId { get; set; }

        /// <summary>
        /// Gets or sets the barcode type, this can be empty
        /// </summary>
        [JsonProperty(PropertyName = "barcodeType")]
        public string BarcodeType { get; set; }

        /// <summary>
        /// Gets or sets the barcode value of the above barcode type
        /// </summary>
        [JsonProperty(PropertyName = "barcodeValue")]
        public string BarcodeValue { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ExternalId");
            }
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (Title == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Title");
            }
            if (Author == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Author");
            }
            if (SourceLastModifiedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceLastModifiedBy");
            }
            if (SourceCreatedBy == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SourceCreatedBy");
            }
            if (ContentVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ContentVersion");
            }
            if (Location == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Location");
            }
            if (MediaType == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "MediaType");
            }
            if (ParentExternalId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ParentExternalId");
            }
            if (SourceProperties != null)
            {
                foreach (var element in SourceProperties)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Represents acknowledgment of item being submitted for further
    /// processing
    /// </summary>
    public partial class ItemAcceptanceModel
    {
        /// <summary>
        /// Initializes a new instance of the ItemAcceptanceModel class.
        /// </summary>
        public ItemAcceptanceModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ItemAcceptanceModel class.
        /// </summary>
        /// <param name="externalId">An external id of an item that has been
        /// submitted for processing</param>
        /// <param name="sourceLastModifiedDate">DateTime stamp when item has
        /// been modified in content source</param>
        /// <param name="aggregationStatus">Returns "Found" - if aggregation
        /// exists in Records365 vNext, "Not found" - if aggregation cannot be
        /// found in Records365 vNext
        /// "Unknown" is a default value and can be returned in case of
        /// exception during search for aggregation</param>
        public ItemAcceptanceModel(string externalId = default(string), System.DateTime? sourceLastModifiedDate = default(System.DateTime?), string aggregationStatus = default(string))
        {
            ExternalId = externalId;
            SourceLastModifiedDate = sourceLastModifiedDate;
            AggregationStatus = aggregationStatus;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets an external id of an item that has been submitted for
        /// processing
        /// </summary>
        [JsonProperty(PropertyName = "externalId")]
        public string ExternalId { get; set; }

        /// <summary>
        /// Gets or sets dateTime stamp when item has been modified in content
        /// source
        /// </summary>
        [JsonProperty(PropertyName = "sourceLastModifiedDate")]
        public System.DateTime? SourceLastModifiedDate { get; set; }

        /// <summary>
        /// Gets or sets returns "Found" - if aggregation exists in Records365
        /// vNext, "Not found" - if aggregation cannot be found in Records365
        /// vNext
        /// "Unknown" is a default value and can be returned in case of
        /// exception during search for aggregation
        /// </summary>
        [JsonProperty(PropertyName = "aggregationStatus")]
        public string AggregationStatus { get; set; }

    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// A notification sent to the Content Source
    /// </summary>
    public partial class ConnectorNotificationModel
    {
        /// <summary>
        /// Initializes a new instance of the ConnectorNotificationModel class.
        /// </summary>
        public ConnectorNotificationModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ConnectorNotificationModel class.
        /// </summary>
        /// <param name="id">Gets or sets unique ID of this notification. The
        /// receiver may use
        /// this value to deduplicate incoming notifications</param>
        /// <param name="notificationType">Gets or sets type of notification.
        /// Possible values include:
        /// 'ItemDestroyed', 'Ping', 'ConnectorConfigAdded',
        /// 'ConnectorConfigUpdated', 'ConnectorConfigDeleted'</param>
        /// <param name="timestamp">Gets or sets UTC timestamp that indicates
        /// when the event occured in
        /// Records365 vNext</param>
        /// <param name="tenantId">Gets or sets the ID of the Records365 vNext
        /// tenant that relates to
        /// this notification</param>
        /// <param name="connectorId">Gets or sets the ID of the connector
        /// instance that relates to this
        /// notification</param>
        /// <param name="item">Gets or sets the item which this notification
        /// relates to. Null if
        /// the notification relates to a connector</param>
        /// <param name="connectorConfig">Gets or sets the connector
        /// configuraiton which this notification
        /// relates to. Null if the notification relates to an item</param>
        public ConnectorNotificationModel(string id = default(string), string notificationType = default(string), System.DateTime? timestamp = default(System.DateTime?), string tenantId = default(string), string connectorId = default(string), ItemSubmissionOutputModel item = default(ItemSubmissionOutputModel), ConnectorConfigModel connectorConfig = default(ConnectorConfigModel))
        {
            Id = id;
            NotificationType = notificationType;
            Timestamp = timestamp;
            TenantId = tenantId;
            ConnectorId = connectorId;
            Item = item;
            ConnectorConfig = connectorConfig;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets unique ID of this notification. The receiver may use
        /// this value to deduplicate incoming notifications
        /// </summary>
        [JsonProperty(PropertyName = "id")]
        public string Id { get; set; }

        /// <summary>
        /// Gets or sets type of notification. Possible values include:
        /// 'ItemDestroyed', 'Ping', 'ConnectorConfigAdded',
        /// 'ConnectorConfigUpdated', 'ConnectorConfigDeleted'
        /// </summary>
        [JsonProperty(PropertyName = "notificationType")]
        public string NotificationType { get; set; }

        /// <summary>
        /// Gets or sets UTC timestamp that indicates when the event occured in
        /// Records365 vNext
        /// </summary>
        [JsonProperty(PropertyName = "timestamp")]
        public System.DateTime? Timestamp { get; set; }

        /// <summary>
        /// Gets or sets the ID of the Records365 vNext tenant that relates to
        /// this notification
        /// </summary>
        [JsonProperty(PropertyName = "tenantId")]
        public string TenantId { get; set; }

        /// <summary>
        /// Gets or sets the ID of the connector instance that relates to this
        /// notification
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets the item which this notification relates to. Null if
        /// the notification relates to a connector
        /// </summary>
        [JsonProperty(PropertyName = "item")]
        public ItemSubmissionOutputModel Item { get; set; }

        /// <summary>
        /// Gets or sets the connector configuraiton which this notification
        /// relates to. Null if the notification relates to an item
        /// </summary>
        [JsonProperty(PropertyName = "connectorConfig")]
        public ConnectorConfigModel ConnectorConfig { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Item != null)
            {
                Item.Validate();
            }
            if (ConnectorConfig != null)
            {
                ConnectorConfig.Validate();
            }
        }
    }
}
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace RecordPoint.Connectors.SDK.Client.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Information sent by a connector to acknowledge that it has processed a
    /// notification.
    /// </summary>
    public partial class ConnectorNotificationAcknowledgeModel
    {
        /// <summary>
        /// Initializes a new instance of the
        /// ConnectorNotificationAcknowledgeModel class.
        /// </summary>
        public ConnectorNotificationAcknowledgeModel()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the
        /// ConnectorNotificationAcknowledgeModel class.
        /// </summary>
        /// <param name="connectorId">Id of the Connector that processed the
        /// notification</param>
        /// <param name="notificationId">Id of the Notification being
        /// acknowledged</param>
        /// <param name="processingResult">Processing result of the
        /// notification. May be OK, Unknown, ConnectorDisabled,
        /// ConnectorNotSubscribed, ConnectorNotReachable,
        /// NotificationError</param>
        /// <param name="connectorStatusMessage">An optional message from the
        /// connector to be added to the items metadata on the
        /// "ConnectorStatusMessage" field</param>
        public ConnectorNotificationAcknowledgeModel(string connectorId, string notificationId, string processingResult, string connectorStatusMessage = default(string))
        {
            ConnectorId = connectorId;
            NotificationId = notificationId;
            ProcessingResult = processingResult;
            ConnectorStatusMessage = connectorStatusMessage;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets id of the Connector that processed the notification
        /// </summary>
        [JsonProperty(PropertyName = "connectorId")]
        public string ConnectorId { get; set; }

        /// <summary>
        /// Gets or sets id of the Notification being acknowledged
        /// </summary>
        [JsonProperty(PropertyName = "notificationId")]
        public string NotificationId { get; set; }

        /// <summary>
        /// Gets or sets processing result of the notification. May be OK,
        /// Unknown, ConnectorDisabled, ConnectorNotSubscribed,
        /// ConnectorNotReachable, NotificationError
        /// </summary>
        [JsonProperty(PropertyName = "processingResult")]
        public string ProcessingResult { get; set; }

        /// <summary>
        /// Gets or sets an optional message from the connector to be added to
        /// the items metadata on the "ConnectorStatusMessage" field
        /// </summary>
        [JsonProperty(PropertyName = "connectorStatusMessage")]
        public string ConnectorStatusMessage { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ConnectorId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ConnectorId");
            }
            if (NotificationId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "NotificationId");
            }
            if (ProcessingResult == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ProcessingResult");
            }
        }
    }
}
